// Code generated by protoc-gen-go. DO NOT EDIT.
// source: services.proto

package gauge_messages

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("services.proto", fileDescriptor_8e16ccb8c5307b32) }

var fileDescriptor_8e16ccb8c5307b32 = []byte{
	// 616 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xdd, 0x6e, 0xd3, 0x4c,
	0x10, 0x95, 0x3e, 0x7d, 0x14, 0x32, 0x2d, 0x29, 0x2c, 0x22, 0xad, 0xca, 0x05, 0x05, 0xca, 0x5f,
	0x05, 0x16, 0x0a, 0xe2, 0x01, 0x4a, 0x93, 0x46, 0x15, 0x6d, 0x15, 0xc5, 0x12, 0xa2, 0x91, 0x10,
	0xda, 0x38, 0x13, 0x67, 0xa9, 0xed, 0x35, 0xbb, 0x63, 0xa0, 0x3c, 0x12, 0xcf, 0xc1, 0x8b, 0xf0,
	0x26, 0xc8, 0xff, 0x49, 0x1c, 0x3b, 0x60, 0xf5, 0x2e, 0xd9, 0x39, 0x73, 0xce, 0x9c, 0x99, 0xd9,
	0x4d, 0xa0, 0xa9, 0x51, 0x7d, 0x15, 0x16, 0x6a, 0xc3, 0x57, 0x92, 0x24, 0x6b, 0xda, 0x3c, 0xb0,
	0xd1, 0x70, 0x51, 0x6b, 0x6e, 0xa3, 0xde, 0x69, 0xa6, 0x9f, 0xe2, 0x78, 0xfb, 0x77, 0x03, 0x1a,
	0xdd, 0xef, 0x68, 0x05, 0x24, 0xa4, 0xc7, 0x86, 0xb0, 0x7d, 0xec, 0x09, 0x12, 0xdc, 0x11, 0x3f,
	0xd0, 0x0c, 0x04, 0x61, 0x87, 0x13, 0x37, 0x49, 0x2a, 0x64, 0x77, 0x8d, 0x79, 0x2a, 0xa3, 0xeb,
	0xfa, 0x74, 0xb9, 0xf3, 0xb4, 0x70, 0x9c, 0xb2, 0x99, 0xc4, 0x29, 0xd0, 0x03, 0xd4, 0xbe, 0xf4,
	0x34, 0x32, 0x0b, 0x9a, 0x26, 0x71, 0x45, 0xb9, 0xda, 0xb3, 0xaa, 0x54, 0x45, 0xc2, 0xb3, 0x07,
	0xf8, 0x25, 0x40, 0x4d, 0x7f, 0x2f, 0x72, 0x0e, 0x5b, 0x33, 0x06, 0x7c, 0xb4, 0xae, 0xae, 0xfe,
	0x0b, 0x60, 0x51, 0x59, 0x21, 0x6b, 0xee, 0xe1, 0xc5, 0x62, 0xfa, 0x5c, 0xb8, 0xb6, 0x8f, 0x8f,
	0x70, 0x6f, 0xc6, 0x87, 0x85, 0x1e, 0x57, 0x42, 0x5e, 0x9d, 0x17, 0x0d, 0xad, 0xd8, 0x4b, 0xc2,
	0x9c, 0xfb, 0x79, 0x55, 0xf0, 0xb3, 0x08, 0xa9, 0xed, 0x29, 0x6b, 0x20, 0xa1, 0x5f, 0xd5, 0xc0,
	0xd9, 0x70, 0x6d, 0xb1, 0x21, 0xac, 0xc7, 0x21, 0x0c, 0xf9, 0xd8, 0xc3, 0xe5, 0x79, 0x51, 0xf0,
	0x9f, 0xb9, 0x3f, 0xc3, 0x9d, 0x23, 0xe1, 0x09, 0x3d, 0x9d, 0x77, 0xb2, 0x5f, 0xe9, 0xa4, 0xeb,
	0x8d, 0xeb, 0xf8, 0x50, 0xb0, 0x95, 0x68, 0x15, 0x46, 0x65, 0xac, 0x1c, 0x55, 0x4d, 0xcd, 0xdc,
	0xdf, 0xdc, 0xaa, 0xef, 0x57, 0xae, 0x7a, 0x4d, 0xad, 0x11, 0x6c, 0xc6, 0x5a, 0xb9, 0xce, 0x93,
	0xd2, 0xdc, 0x7a, 0x1a, 0xed, 0x5f, 0xd7, 0xa0, 0x71, 0x10, 0xd0, 0x54, 0x2a, 0xe1, 0xd9, 0xac,
	0x03, 0x8d, 0x43, 0x6e, 0x4d, 0xf1, 0x48, 0x38, 0xc8, 0x76, 0x17, 0x39, 0xb2, 0x50, 0xaa, 0xb2,
	0xfc, 0xaa, 0xb1, 0x3e, 0xac, 0xf7, 0x30, 0x5a, 0xe5, 0x33, 0xee, 0x22, 0xbb, 0xbf, 0x6c, 0xf6,
	0x61, 0x24, 0xa5, 0xd9, 0x2d, 0x07, 0x24, 0x9d, 0xf8, 0x04, 0x9b, 0x3d, 0xa4, 0x9e, 0x23, 0x47,
	0x7d, 0x4e, 0x84, 0xca, 0xd3, 0x65, 0xd7, 0xfc, 0xcd, 0xe2, 0xf1, 0xb1, 0xeb, 0x3b, 0xe8, 0xa2,
	0x47, 0x3c, 0x74, 0x1f, 0x56, 0x3f, 0x43, 0x93, 0x09, 0x98, 0xb0, 0x31, 0x53, 0xb2, 0x66, 0xa5,
	0x25, 0xe9, 0xb4, 0xe8, 0x07, 0x15, 0x88, 0xac, 0xea, 0x5b, 0x09, 0x69, 0x5f, 0x6a, 0x11, 0xca,
	0x6b, 0xb6, 0xb7, 0x2c, 0x2d, 0x0b, 0xa7, 0xe4, 0x8f, 0x57, 0xa0, 0x32, 0x81, 0x56, 0x0f, 0xa9,
	0xe8, 0xb0, 0xb4, 0x3b, 0xc6, 0xea, 0xee, 0x9c, 0x08, 0x4d, 0x99, 0xc0, 0x07, 0xb8, 0x99, 0x21,
	0x4c, 0x0a, 0x46, 0xec, 0x65, 0xb1, 0xb0, 0x60, 0x34, 0x4f, 0x72, 0x28, 0xc7, 0xd9, 0x64, 0xb7,
	0x17, 0xe1, 0xa1, 0x42, 0x47, 0x4c, 0x26, 0xec, 0x14, 0x6e, 0x0c, 0x70, 0xc2, 0x2d, 0x92, 0xaa,
	0xb8, 0x20, 0x69, 0xa4, 0x74, 0x41, 0x72, 0x40, 0xb2, 0xc6, 0x43, 0x58, 0x1b, 0xa0, 0x0e, 0x1c,
	0x62, 0x7d, 0xb8, 0x7d, 0x26, 0x49, 0x4c, 0x2e, 0xa3, 0x9f, 0xe8, 0xe4, 0xb0, 0xd8, 0xf5, 0x30,
	0x98, 0xdd, 0x89, 0x18, 0x55, 0xb2, 0xce, 0xed, 0x09, 0x34, 0xde, 0x73, 0x47, 0x8c, 0x79, 0x58,
	0xeb, 0x39, 0x6c, 0x24, 0x5f, 0xe2, 0xc7, 0xf3, 0xd1, 0xb2, 0x49, 0xa5, 0x88, 0xb4, 0xfe, 0xbd,
	0x6a, 0x50, 0xe2, 0xe1, 0x04, 0xae, 0xf7, 0x95, 0xb4, 0x50, 0x6b, 0x76, 0x00, 0xff, 0xbf, 0x13,
	0x8e, 0x53, 0x7c, 0x9a, 0xc3, 0xd3, 0x04, 0x54, 0x7d, 0x09, 0xdf, 0x3e, 0x87, 0x96, 0x25, 0x5d,
	0x83, 0xa6, 0x32, 0xb0, 0xa7, 0xf4, 0x4d, 0xaa, 0x0b, 0x1d, 0x03, 0x7f, 0xfe, 0xd7, 0xec, 0x45,
	0x09, 0xa7, 0x49, 0xc2, 0x68, 0x2d, 0xfa, 0xbb, 0xf3, 0xfa, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xab, 0x5a, 0xaa, 0x6a, 0x20, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ExecutionClient is the client API for Execution service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ExecutionClient interface {
	// SuiteDataStoreInit is a RPC to initialize the suite level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeSuiteDataStore(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ExecutionStarting is a RPC to tell runner to execute Suite level hooks.
	//
	// Accepts a ExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartExecution(ctx context.Context, in *ExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// SpecDataStoreInit is a RPC to initialize the spec level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeSpecDataStore(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// SpecExecutionStarting is a RPC to tell runner to execute spec level hooks.
	//
	// Accepts a SpecExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartSpecExecution(ctx context.Context, in *SpecExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ScenarioDataStoreInit is a RPC to initialize the scenario level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeScenarioDataStore(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ScenarioExecutionStarting is a RPC to tell runner to execute scenario level hooks.
	//
	// Accepts a ScenarioExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartScenarioExecution(ctx context.Context, in *ScenarioExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// StepExecutionStarting is a RPC to tell runner to execute step level hooks.
	//
	// Accepts a StepExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartStepExecution(ctx context.Context, in *StepExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ExecuteStep is a RPC to tell runner to execute a step .
	//
	// Accepts a ExecuteStepRequest message and returns a ExecutionStatusResponse message
	ExecuteStep(ctx context.Context, in *ExecuteStepRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// StepExecutionEnding is a RPC to tell runner to execute step level hooks.
	//
	// Accepts a StepExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishStepExecution(ctx context.Context, in *StepExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ScenarioExecutionEnding is a RPC to tell runner to execute Scenario level hooks.
	//
	// Accepts a ScenarioExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishScenarioExecution(ctx context.Context, in *ScenarioExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// SpecExecutionEnding is a RPC to tell runner to execute spec level hooks.
	//
	// Accepts a SpecExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishSpecExecution(ctx context.Context, in *SpecExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
	// ExecutionEnding is a RPC to tell runner to execute suite level hooks.
	//
	// Accepts a ExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishExecution(ctx context.Context, in *ExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error)
}

type executionClient struct {
	cc *grpc.ClientConn
}

func NewExecutionClient(cc *grpc.ClientConn) ExecutionClient {
	return &executionClient{cc}
}

func (c *executionClient) InitializeSuiteDataStore(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Execution/InitializeSuiteDataStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionClient) StartExecution(ctx context.Context, in *ExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Execution/StartExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionClient) InitializeSpecDataStore(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Execution/InitializeSpecDataStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionClient) StartSpecExecution(ctx context.Context, in *SpecExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Execution/StartSpecExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionClient) InitializeScenarioDataStore(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Execution/InitializeScenarioDataStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionClient) StartScenarioExecution(ctx context.Context, in *ScenarioExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Execution/StartScenarioExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionClient) StartStepExecution(ctx context.Context, in *StepExecutionStartingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Execution/StartStepExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionClient) ExecuteStep(ctx context.Context, in *ExecuteStepRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Execution/ExecuteStep", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionClient) FinishStepExecution(ctx context.Context, in *StepExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Execution/FinishStepExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionClient) FinishScenarioExecution(ctx context.Context, in *ScenarioExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Execution/FinishScenarioExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionClient) FinishSpecExecution(ctx context.Context, in *SpecExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Execution/FinishSpecExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionClient) FinishExecution(ctx context.Context, in *ExecutionEndingRequest, opts ...grpc.CallOption) (*ExecutionStatusResponse, error) {
	out := new(ExecutionStatusResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Execution/FinishExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExecutionServer is the server API for Execution service.
type ExecutionServer interface {
	// SuiteDataStoreInit is a RPC to initialize the suite level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeSuiteDataStore(context.Context, *Empty) (*ExecutionStatusResponse, error)
	// ExecutionStarting is a RPC to tell runner to execute Suite level hooks.
	//
	// Accepts a ExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartExecution(context.Context, *ExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// SpecDataStoreInit is a RPC to initialize the spec level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeSpecDataStore(context.Context, *Empty) (*ExecutionStatusResponse, error)
	// SpecExecutionStarting is a RPC to tell runner to execute spec level hooks.
	//
	// Accepts a SpecExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartSpecExecution(context.Context, *SpecExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// ScenarioDataStoreInit is a RPC to initialize the scenario level data store.
	//
	// Accepts a Empty message and returns a ExecutionStatusResponse message
	InitializeScenarioDataStore(context.Context, *Empty) (*ExecutionStatusResponse, error)
	// ScenarioExecutionStarting is a RPC to tell runner to execute scenario level hooks.
	//
	// Accepts a ScenarioExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartScenarioExecution(context.Context, *ScenarioExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// StepExecutionStarting is a RPC to tell runner to execute step level hooks.
	//
	// Accepts a StepExecutionStartingRequest message and returns a ExecutionStatusResponse message
	StartStepExecution(context.Context, *StepExecutionStartingRequest) (*ExecutionStatusResponse, error)
	// ExecuteStep is a RPC to tell runner to execute a step .
	//
	// Accepts a ExecuteStepRequest message and returns a ExecutionStatusResponse message
	ExecuteStep(context.Context, *ExecuteStepRequest) (*ExecutionStatusResponse, error)
	// StepExecutionEnding is a RPC to tell runner to execute step level hooks.
	//
	// Accepts a StepExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishStepExecution(context.Context, *StepExecutionEndingRequest) (*ExecutionStatusResponse, error)
	// ScenarioExecutionEnding is a RPC to tell runner to execute Scenario level hooks.
	//
	// Accepts a ScenarioExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishScenarioExecution(context.Context, *ScenarioExecutionEndingRequest) (*ExecutionStatusResponse, error)
	// SpecExecutionEnding is a RPC to tell runner to execute spec level hooks.
	//
	// Accepts a SpecExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishSpecExecution(context.Context, *SpecExecutionEndingRequest) (*ExecutionStatusResponse, error)
	// ExecutionEnding is a RPC to tell runner to execute suite level hooks.
	//
	// Accepts a ExecutionEndingRequest message and returns a ExecutionStatusResponse message
	FinishExecution(context.Context, *ExecutionEndingRequest) (*ExecutionStatusResponse, error)
}

func RegisterExecutionServer(s *grpc.Server, srv ExecutionServer) {
	s.RegisterService(&_Execution_serviceDesc, srv)
}

func _Execution_InitializeSuiteDataStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServer).InitializeSuiteDataStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Execution/InitializeSuiteDataStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServer).InitializeSuiteDataStore(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Execution_StartExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServer).StartExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Execution/StartExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServer).StartExecution(ctx, req.(*ExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Execution_InitializeSpecDataStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServer).InitializeSpecDataStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Execution/InitializeSpecDataStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServer).InitializeSpecDataStore(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Execution_StartSpecExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServer).StartSpecExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Execution/StartSpecExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServer).StartSpecExecution(ctx, req.(*SpecExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Execution_InitializeScenarioDataStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServer).InitializeScenarioDataStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Execution/InitializeScenarioDataStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServer).InitializeScenarioDataStore(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Execution_StartScenarioExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScenarioExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServer).StartScenarioExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Execution/StartScenarioExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServer).StartScenarioExecution(ctx, req.(*ScenarioExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Execution_StartStepExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepExecutionStartingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServer).StartStepExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Execution/StartStepExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServer).StartStepExecution(ctx, req.(*StepExecutionStartingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Execution_ExecuteStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteStepRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServer).ExecuteStep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Execution/ExecuteStep",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServer).ExecuteStep(ctx, req.(*ExecuteStepRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Execution_FinishStepExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServer).FinishStepExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Execution/FinishStepExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServer).FinishStepExecution(ctx, req.(*StepExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Execution_FinishScenarioExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScenarioExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServer).FinishScenarioExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Execution/FinishScenarioExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServer).FinishScenarioExecution(ctx, req.(*ScenarioExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Execution_FinishSpecExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpecExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServer).FinishSpecExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Execution/FinishSpecExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServer).FinishSpecExecution(ctx, req.(*SpecExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Execution_FinishExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionEndingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServer).FinishExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Execution/FinishExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServer).FinishExecution(ctx, req.(*ExecutionEndingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Execution_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gauge.messages.Execution",
	HandlerType: (*ExecutionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitializeSuiteDataStore",
			Handler:    _Execution_InitializeSuiteDataStore_Handler,
		},
		{
			MethodName: "StartExecution",
			Handler:    _Execution_StartExecution_Handler,
		},
		{
			MethodName: "InitializeSpecDataStore",
			Handler:    _Execution_InitializeSpecDataStore_Handler,
		},
		{
			MethodName: "StartSpecExecution",
			Handler:    _Execution_StartSpecExecution_Handler,
		},
		{
			MethodName: "InitializeScenarioDataStore",
			Handler:    _Execution_InitializeScenarioDataStore_Handler,
		},
		{
			MethodName: "StartScenarioExecution",
			Handler:    _Execution_StartScenarioExecution_Handler,
		},
		{
			MethodName: "StartStepExecution",
			Handler:    _Execution_StartStepExecution_Handler,
		},
		{
			MethodName: "ExecuteStep",
			Handler:    _Execution_ExecuteStep_Handler,
		},
		{
			MethodName: "FinishStepExecution",
			Handler:    _Execution_FinishStepExecution_Handler,
		},
		{
			MethodName: "FinishScenarioExecution",
			Handler:    _Execution_FinishScenarioExecution_Handler,
		},
		{
			MethodName: "FinishSpecExecution",
			Handler:    _Execution_FinishSpecExecution_Handler,
		},
		{
			MethodName: "FinishExecution",
			Handler:    _Execution_FinishExecution_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}

// AuthoringClient is the client API for Authoring service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AuthoringClient interface {
	// CacheFile is a RPC to tell runner to load/reload/unload a implementation file.
	//
	// Accepts a CacheFileRequest message and returns a Empty message
	CacheFile(ctx context.Context, in *CacheFileRequest, opts ...grpc.CallOption) (*Empty, error)
	// GetStepName is a RPC to get information about the given step.
	//
	// Accepts a StepNameRequest message and returns a StepNameResponse message.
	GetStepName(ctx context.Context, in *StepNameRequest, opts ...grpc.CallOption) (*StepNameResponse, error)
	// GetGlobPatterns is a RPC to get the file path pattern which needs to be cached.
	//
	// Accepts a Empty message and returns a ImplementationFileGlobPatternResponse message.
	GetGlobPatterns(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ImplementationFileGlobPatternResponse, error)
	// GetStepNames is a RPC to get all the available steps from the runner.
	//
	// Accepts a StepNamesRequest message and returns a StepNamesResponse
	GetStepNames(ctx context.Context, in *StepNamesRequest, opts ...grpc.CallOption) (*StepNamesResponse, error)
	// GetStepPositions is a RPC to get positions of all available steps in a given file.
	//
	// Accepts a StepPositionsRequest message and returns a StepPositionsResponse message
	GetStepPositions(ctx context.Context, in *StepPositionsRequest, opts ...grpc.CallOption) (*StepPositionsResponse, error)
	// GetImplementationFiles is a RPC get all the existing implementation files.
	//
	// Accepts a Empty and returns a ImplementationFileListResponse message.
	GetImplementationFiles(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ImplementationFileListResponse, error)
	// ImplementStub is a RPC to to ask runner to add a given implementation to given file.
	//
	// Accepts a StubImplementationCodeRequest and returns a FileDiff message.
	ImplementStub(ctx context.Context, in *StubImplementationCodeRequest, opts ...grpc.CallOption) (*FileDiff, error)
	// Refactor is a RPC to refactor a given step in implementation file.
	//
	// Accepts a RefactorRequest message and returns a RefactorResponse message.
	Refactor(ctx context.Context, in *RefactorRequest, opts ...grpc.CallOption) (*RefactorResponse, error)
}

type authoringClient struct {
	cc *grpc.ClientConn
}

func NewAuthoringClient(cc *grpc.ClientConn) AuthoringClient {
	return &authoringClient{cc}
}

func (c *authoringClient) CacheFile(ctx context.Context, in *CacheFileRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Authoring/CacheFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authoringClient) GetStepName(ctx context.Context, in *StepNameRequest, opts ...grpc.CallOption) (*StepNameResponse, error) {
	out := new(StepNameResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Authoring/GetStepName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authoringClient) GetGlobPatterns(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ImplementationFileGlobPatternResponse, error) {
	out := new(ImplementationFileGlobPatternResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Authoring/GetGlobPatterns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authoringClient) GetStepNames(ctx context.Context, in *StepNamesRequest, opts ...grpc.CallOption) (*StepNamesResponse, error) {
	out := new(StepNamesResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Authoring/GetStepNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authoringClient) GetStepPositions(ctx context.Context, in *StepPositionsRequest, opts ...grpc.CallOption) (*StepPositionsResponse, error) {
	out := new(StepPositionsResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Authoring/GetStepPositions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authoringClient) GetImplementationFiles(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ImplementationFileListResponse, error) {
	out := new(ImplementationFileListResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Authoring/GetImplementationFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authoringClient) ImplementStub(ctx context.Context, in *StubImplementationCodeRequest, opts ...grpc.CallOption) (*FileDiff, error) {
	out := new(FileDiff)
	err := c.cc.Invoke(ctx, "/gauge.messages.Authoring/ImplementStub", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authoringClient) Refactor(ctx context.Context, in *RefactorRequest, opts ...grpc.CallOption) (*RefactorResponse, error) {
	out := new(RefactorResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Authoring/Refactor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthoringServer is the server API for Authoring service.
type AuthoringServer interface {
	// CacheFile is a RPC to tell runner to load/reload/unload a implementation file.
	//
	// Accepts a CacheFileRequest message and returns a Empty message
	CacheFile(context.Context, *CacheFileRequest) (*Empty, error)
	// GetStepName is a RPC to get information about the given step.
	//
	// Accepts a StepNameRequest message and returns a StepNameResponse message.
	GetStepName(context.Context, *StepNameRequest) (*StepNameResponse, error)
	// GetGlobPatterns is a RPC to get the file path pattern which needs to be cached.
	//
	// Accepts a Empty message and returns a ImplementationFileGlobPatternResponse message.
	GetGlobPatterns(context.Context, *Empty) (*ImplementationFileGlobPatternResponse, error)
	// GetStepNames is a RPC to get all the available steps from the runner.
	//
	// Accepts a StepNamesRequest message and returns a StepNamesResponse
	GetStepNames(context.Context, *StepNamesRequest) (*StepNamesResponse, error)
	// GetStepPositions is a RPC to get positions of all available steps in a given file.
	//
	// Accepts a StepPositionsRequest message and returns a StepPositionsResponse message
	GetStepPositions(context.Context, *StepPositionsRequest) (*StepPositionsResponse, error)
	// GetImplementationFiles is a RPC get all the existing implementation files.
	//
	// Accepts a Empty and returns a ImplementationFileListResponse message.
	GetImplementationFiles(context.Context, *Empty) (*ImplementationFileListResponse, error)
	// ImplementStub is a RPC to to ask runner to add a given implementation to given file.
	//
	// Accepts a StubImplementationCodeRequest and returns a FileDiff message.
	ImplementStub(context.Context, *StubImplementationCodeRequest) (*FileDiff, error)
	// Refactor is a RPC to refactor a given step in implementation file.
	//
	// Accepts a RefactorRequest message and returns a RefactorResponse message.
	Refactor(context.Context, *RefactorRequest) (*RefactorResponse, error)
}

func RegisterAuthoringServer(s *grpc.Server, srv AuthoringServer) {
	s.RegisterService(&_Authoring_serviceDesc, srv)
}

func _Authoring_CacheFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CacheFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthoringServer).CacheFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Authoring/CacheFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthoringServer).CacheFile(ctx, req.(*CacheFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authoring_GetStepName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthoringServer).GetStepName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Authoring/GetStepName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthoringServer).GetStepName(ctx, req.(*StepNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authoring_GetGlobPatterns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthoringServer).GetGlobPatterns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Authoring/GetGlobPatterns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthoringServer).GetGlobPatterns(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authoring_GetStepNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthoringServer).GetStepNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Authoring/GetStepNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthoringServer).GetStepNames(ctx, req.(*StepNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authoring_GetStepPositions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepPositionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthoringServer).GetStepPositions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Authoring/GetStepPositions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthoringServer).GetStepPositions(ctx, req.(*StepPositionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authoring_GetImplementationFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthoringServer).GetImplementationFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Authoring/GetImplementationFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthoringServer).GetImplementationFiles(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authoring_ImplementStub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StubImplementationCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthoringServer).ImplementStub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Authoring/ImplementStub",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthoringServer).ImplementStub(ctx, req.(*StubImplementationCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authoring_Refactor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefactorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthoringServer).Refactor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Authoring/Refactor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthoringServer).Refactor(ctx, req.(*RefactorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Authoring_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gauge.messages.Authoring",
	HandlerType: (*AuthoringServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CacheFile",
			Handler:    _Authoring_CacheFile_Handler,
		},
		{
			MethodName: "GetStepName",
			Handler:    _Authoring_GetStepName_Handler,
		},
		{
			MethodName: "GetGlobPatterns",
			Handler:    _Authoring_GetGlobPatterns_Handler,
		},
		{
			MethodName: "GetStepNames",
			Handler:    _Authoring_GetStepNames_Handler,
		},
		{
			MethodName: "GetStepPositions",
			Handler:    _Authoring_GetStepPositions_Handler,
		},
		{
			MethodName: "GetImplementationFiles",
			Handler:    _Authoring_GetImplementationFiles_Handler,
		},
		{
			MethodName: "ImplementStub",
			Handler:    _Authoring_ImplementStub_Handler,
		},
		{
			MethodName: "Refactor",
			Handler:    _Authoring_Refactor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}

// ResultClient is the client API for Result service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ResultClient interface {
	// NotifySuiteResult is a RPC to tell about the end result of execution
	//
	// Accepts a SuiteExecutionResult message and returns a Empty message.
	NotifySuiteResult(ctx context.Context, in *SuiteExecutionResult, opts ...grpc.CallOption) (*Empty, error)
}

type resultClient struct {
	cc *grpc.ClientConn
}

func NewResultClient(cc *grpc.ClientConn) ResultClient {
	return &resultClient{cc}
}

func (c *resultClient) NotifySuiteResult(ctx context.Context, in *SuiteExecutionResult, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Result/NotifySuiteResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ResultServer is the server API for Result service.
type ResultServer interface {
	// NotifySuiteResult is a RPC to tell about the end result of execution
	//
	// Accepts a SuiteExecutionResult message and returns a Empty message.
	NotifySuiteResult(context.Context, *SuiteExecutionResult) (*Empty, error)
}

func RegisterResultServer(s *grpc.Server, srv ResultServer) {
	s.RegisterService(&_Result_serviceDesc, srv)
}

func _Result_NotifySuiteResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuiteExecutionResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResultServer).NotifySuiteResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Result/NotifySuiteResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResultServer).NotifySuiteResult(ctx, req.(*SuiteExecutionResult))
	}
	return interceptor(ctx, in, info, handler)
}

var _Result_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gauge.messages.Result",
	HandlerType: (*ResultServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NotifySuiteResult",
			Handler:    _Result_NotifySuiteResult_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}

// ValidatorClient is the client API for Validator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ValidatorClient interface {
	// ValidateStep is a RPC to validate a given step.
	//
	// Accepts a StepValidateRequest message and returns a StepValidateResponse message
	ValidateStep(ctx context.Context, in *StepValidateRequest, opts ...grpc.CallOption) (*StepValidateResponse, error)
}

type validatorClient struct {
	cc *grpc.ClientConn
}

func NewValidatorClient(cc *grpc.ClientConn) ValidatorClient {
	return &validatorClient{cc}
}

func (c *validatorClient) ValidateStep(ctx context.Context, in *StepValidateRequest, opts ...grpc.CallOption) (*StepValidateResponse, error) {
	out := new(StepValidateResponse)
	err := c.cc.Invoke(ctx, "/gauge.messages.Validator/ValidateStep", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ValidatorServer is the server API for Validator service.
type ValidatorServer interface {
	// ValidateStep is a RPC to validate a given step.
	//
	// Accepts a StepValidateRequest message and returns a StepValidateResponse message
	ValidateStep(context.Context, *StepValidateRequest) (*StepValidateResponse, error)
}

func RegisterValidatorServer(s *grpc.Server, srv ValidatorServer) {
	s.RegisterService(&_Validator_serviceDesc, srv)
}

func _Validator_ValidateStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepValidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidatorServer).ValidateStep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Validator/ValidateStep",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidatorServer).ValidateStep(ctx, req.(*StepValidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Validator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gauge.messages.Validator",
	HandlerType: (*ValidatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ValidateStep",
			Handler:    _Validator_ValidateStep_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}

// ProcessClient is the client API for Process service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ProcessClient interface {
	// Kill is a RPC tell plugin to stop grpc server and kill the plugin process.
	//
	// Accepts a KillProcessRequest message and returns a Empty message.
	Kill(ctx context.Context, in *KillProcessRequest, opts ...grpc.CallOption) (*Empty, error)
}

type processClient struct {
	cc *grpc.ClientConn
}

func NewProcessClient(cc *grpc.ClientConn) ProcessClient {
	return &processClient{cc}
}

func (c *processClient) Kill(ctx context.Context, in *KillProcessRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/gauge.messages.Process/Kill", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProcessServer is the server API for Process service.
type ProcessServer interface {
	// Kill is a RPC tell plugin to stop grpc server and kill the plugin process.
	//
	// Accepts a KillProcessRequest message and returns a Empty message.
	Kill(context.Context, *KillProcessRequest) (*Empty, error)
}

func RegisterProcessServer(s *grpc.Server, srv ProcessServer) {
	s.RegisterService(&_Process_serviceDesc, srv)
}

func _Process_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gauge.messages.Process/Kill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessServer).Kill(ctx, req.(*KillProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Process_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gauge.messages.Process",
	HandlerType: (*ProcessServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Kill",
			Handler:    _Process_Kill_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services.proto",
}
